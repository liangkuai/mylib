# 哈希表

> 根据 key 直接获取 value 的数据结构。
>
> 通过一个关于 key 的函数计算的到一个值，这个值是 value 在哈希表里的位置索引，再这个位置索引直接访问 value。其中，关于 key 的函数就是哈希函数，通过哈希函数计算出来的值就是哈希值。

![哈希表](/assets/images/data-structure/hashtable/hashtable.jpeg)

### 1. 存储结构：数组

哈希表基于数组作为存储结构。因为数组具备随机存储访问的特性。数组下标与数组元素一一映射，通过数组下标可以直接访问对应的数组元素，时间复杂度是 O(1)。


### 2. 哈希表的性能

虽然哈希表是基于数组实现，但查询效率并不能完全认为是 O(1)。它的查询效率跟这3个要素都有关系。

- 哈希函数（哈希算法）
- 哈希冲突解决方法
- 负载因子/扩容机制

#### 2.1 哈希函数（哈希算法）

理想的哈希函数，希望能够做到

> 如果 `key1 != key2`，那么 `hash(key1) != hash(key2)`。

但事实上，**再好的哈希函数都无法避免哈希冲突**。

**哈希函数是设计哈希表的关键，直接决定了哈希碰撞的概率和哈希表的性能**。在哈希桶数组长度固定的情况下，哈希函数计算结果越分散均匀，发生哈希碰撞的概率就越小。

> #### 一个好的哈希函数至少要满足这两个要求
>
> 1. 哈希冲突的概率低。计算后的值能平均分布，也就是一组数据能均匀地散列在各个桶中。
> 2. 哈希函数执行速度要快。

所以，哈希函数用一般都比较简单，比较追求效率。

#### 2.2 哈希冲突解决方法

参考：[哈希冲突解决方法](/docs/data-structure/hashtable/哈希冲突.md)

#### 2.3 负载因子 / 扩容机制

参考：[负载因子 / 扩容机制](/docs/data-structure/hashtable/负载因子_扩容机制.md)


### 3. 参考



## 经典题型

- [1. 两数之和](https://leetcode-cn.com/problems/two-sum/) `easy`
- [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/) `medinum`
